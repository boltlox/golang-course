### Алгоритм для исследования

```go
func MinEl2(a []int) int {
	// только для первичной проверки
	if len(a) == 0 {
		return 0
	}
	if len(a) == 1 {
		return a[0]
	}
	t1 := MinEl2(a[:len(a)/2])
	t2 := MinEl2(a[len(a)/2:])
	if t1 <= t2 {
		return t1
	}
	return t2
}
```

### Решение

Размер входных данных определяется длиной слайса $n$.

Основная операция алгоритма - это сравнение элементов, которое происходит в выражении `if t1 <= t2`.

Число основных операций зависит только от длины слайса $n$, так как на каждой рекурсивной итерации происходит одно сравнение.

Рекуррентное уравнение для данного алгоритма можно записать следующим образом:
$$
T(n) = 2T\left(\frac{n}{2}\right) + 1,
$$
где $T(n)$ - количество основных операций для слайса длины $n$.

Начальное условие:
$$
T(1) = 1
$$
поскольку для слайса длиной 1 нужно всего одно сравнение.

Для решения рекуррентного уравнения:
$$
T(n) = 2T\left(\frac{n}{2}\right) + 1
$$

Проанализируем последовательность:
$$
\begin{aligned}
T(n) &= 2T\left(\frac{n}{2}\right) + 1 \\
     &= 2\left(2T\left(\frac{n}{4}\right) + 1\right) + 1 \\
     &= 4T\left(\frac{n}{4}\right) + 3 \\
     &= 8T\left(\frac{n}{8}\right) + 7 \\
     &= 2^k T\left(\frac{n}{2^k}\right) + (2^k - 1),
\end{aligned}
$$

где $\frac{n}{2^k} = 1$, следовательно, $k = \log_2 n$:

$$
\begin{aligned}
T(n) &= 2^{\log_2 n} T(1) + (2^{\log_2 n} - 1) \\
     &= n \cdot 1 + (n - 1) \\
     &= n + n - 1 \\
     &= 2n - 1
\end{aligned}
$$

Таким образом, решение рекуррентного уравнения:
$$
T(n) = O(n)
$$


Оба алгоритма `MinEl` и `MinEl2` имеют одинаковую временную сложность $O(n)$, так как они оба должны проверить каждый элемент среза хотя бы один раз, чтобы найти минимальный элемент.

Однако, есть некоторые различия в их работе:

- **Алгоритм `MinEl`**: Обходит элементы последовательно, начиная с конца массива.
- **Алгоритм `MinEl2`**: Разделяет массив на две части и рекурсивно ищет минимальные элементы в каждой части, что делает его более подходящим для параллельной обработки.

Таким образом, хотя оба алгоритма имеют одинаковую временную сложность, `MinEl2` может быть более эффективным в системах, где поддерживается параллелизм, из-за возможности выполнять рекурсивные вызовы параллельно.

### Изменение алгоритма

Для повышения скорости выполнения функции можно использовать параллельные вычисления, так как `MinEl2` разделяет массив на две части. В Go это можно сделать с помощью горутин и канала для сбора результатов. Это позволит выполнять рекурсивные вызовы параллельно, что может значительно ускорить выполнение на многопроцессорных системах.

```go
package main

import (
	"fmt"
	"sync"
)

func MinEl2(a []int) int {
	if len(a) == 0 {
		return 0
	}
	if len(a) == 1 {
		return a[0]
	}
	var wg sync.WaitGroup
	wg.Add(2)

	var t1, t2 int
	mid := len(a) / 2

	// Горутина для поиска минимального элемента в первой половине
	go func() {
		defer wg.Done()
		t1 = MinEl2(a[:mid])
	}()

	// Горутина для поиска минимального элемента во второй половине
	go func() {
		defer wg.Done()
		t2 = MinEl2(a[mid:])
	}()

	// Ожидание завершения обеих горутин
	wg.Wait()

	if t1 <= t2 {
		return t1
	}
	return t2
}

func main() {
	a := []int{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5}
	fmt.Println(MinEl2(a)) // Вывод: 1
}
```

Оригинальный алгоритм `MinEl2` имеет временную сложность $O(n)$, так как каждый элемент проверяется один раз.

При использовании параллельных вычислений, теоретически, временная сложность может быть улучшена следующим образом:

- Каждый рекурсивный вызов делит массив на две части и запускается параллельно.
- Это уменьшает высоту рекурсивного дерева до $\log_2 n$.
- Если каждая параллельная ветвь обрабатывается за $O(1)$ времени (что на практике не всегда возможно из-за накладных расходов на создание и синхронизацию горутин), временная сложность может быть улучшена до:

$$
T(n) = O(\log n)
$$

Однако, важно учитывать накладные расходы на создание и управление горутинами. В реальных системах это будет означать, что временная сложность на практике может быть ближе к:

$$
T(n) = O\left(\frac{n}{p} + \log n\right),
$$
где $p$ - количество процессоров.
